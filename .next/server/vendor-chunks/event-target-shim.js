"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/event-target-shim";
exports.ids = ["vendor-chunks/event-target-shim"];
exports.modules = {

/***/ "(action-browser)/./node_modules/event-target-shim/dist/event-target-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/event-target-shim/dist/event-target-shim.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

eval("/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */ /**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */ const privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */ const wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */ function pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */ function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n        }\n        return;\n    }\n    if (!data.event.cancelable) {\n        return;\n    }\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */ /**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */ function Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now()\n    });\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", {\n        value: false,\n        enumerable: true\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */ get type () {\n        return pd(this).event.type;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get target () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */ composedPath () {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return [];\n        }\n        return [\n            currentTarget\n        ];\n    },\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */ get NONE () {\n        return 0;\n    },\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */ get CAPTURING_PHASE () {\n        return 1;\n    },\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */ get AT_TARGET () {\n        return 2;\n    },\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */ get BUBBLING_PHASE () {\n        return 3;\n    },\n    /**\n     * The target of this event.\n     * @type {number}\n     */ get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopPropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopImmediatePropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */ get bubbles () {\n        return Boolean(pd(this).event.bubbles);\n    },\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */ get cancelable () {\n        return Boolean(pd(this).event.cancelable);\n    },\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */ preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */ get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */ get composed () {\n        return Boolean(pd(this).event.composed);\n    },\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */ get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */ get srcElement () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */ get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (value){\n        if (!value) {\n            return;\n        }\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */ get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (value){\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */ initEvent () {\n    // Do nothing.\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n});\n// Ensure `event instanceof window.Event` is `true`.\nif (false) {}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */ function defineRedirectDescriptor(key) {\n    return {\n        get () {\n            return pd(this).event[key];\n        },\n        set (value1) {\n            pd(this).event[key] = value1;\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */ function defineCallDescriptor(key) {\n    return {\n        value () {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments);\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */ function defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent;\n    }\n    /** CustomEvent */ function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: {\n            value: CustomEvent,\n            configurable: true,\n            writable: true\n        }\n    });\n    // Define accessors.\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n        }\n    }\n    return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */ function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event;\n    }\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */ function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */ function isStopped(event) {\n    return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */ function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */ function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */ function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */ /**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */ const listenersMap = new WeakMap();\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */ function isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n    ;\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */ function getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n    return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */ function defineEventAttributeDescriptor(eventName) {\n    return {\n        get () {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener;\n                }\n                node = node.next;\n            }\n            return null;\n        },\n        set (listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n                node = node.next;\n            }\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */ function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */ function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */ function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true\n        }\n    });\n    for(let i = 0; i < eventNames.length; ++i){\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */ function EventTarget() {\n    /*eslint-disable consistent-return */ if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0]);\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; ++i){\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n/*eslint-enable consistent-return */ }\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ addEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\");\n        }\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null\n        };\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return;\n        }\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n        // Add it.\n        prev.next = newNode;\n    },\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ removeEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        let prev = null;\n        let node = listeners.get(eventName);\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n    },\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */ dispatchEvent (event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.');\n        }\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true;\n        }\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while(node != null){\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n            // Call this listener\n            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err);\n                    }\n                }\n            } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break;\n            }\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n        return !wrappedEvent.defaultPrevented;\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n});\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (false) {}\nexports.defineEventAttribute = defineEventAttribute;\nexports.EventTarget = EventTarget;\nexports[\"default\"] = EventTarget;\nmodule.exports = EventTarget;\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget;\nmodule.exports.defineEventAttribute = defineEventAttribute //# sourceMappingURL=event-target-shim.js.map\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9kaXN0L2V2ZW50LXRhcmdldC1zaGltLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FDRDtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RDs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRDs7OztDQUlDLEdBQ0QsTUFBTUMsY0FBYyxJQUFJQztBQUV4Qjs7OztDQUlDLEdBQ0QsTUFBTUMsV0FBVyxJQUFJRDtBQUVyQjs7Ozs7Q0FLQyxHQUNELFNBQVNFLEdBQUdDLEtBQUs7SUFDYixNQUFNQyxPQUFPTCxZQUFZTSxHQUFHLENBQUNGO0lBQzdCRyxRQUFRQyxNQUFNLENBQ1ZILFFBQVEsTUFDUiwrQ0FDQUQ7SUFFSixPQUFPQztBQUNYO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0ksY0FBY0MsSUFBSTtJQUN2QixJQUFJQSxLQUFLQyxlQUFlLElBQUksTUFBTTtRQUM5QixJQUNJLE9BQU9KLFlBQVksZUFDbkIsT0FBT0EsUUFBUUssS0FBSyxLQUFLLFlBQzNCO1lBQ0VMLFFBQVFLLEtBQUssQ0FDVCxzRUFDQUYsS0FBS0MsZUFBZTtRQUU1QjtRQUNBO0lBQ0o7SUFDQSxJQUFJLENBQUNELEtBQUtOLEtBQUssQ0FBQ1MsVUFBVSxFQUFFO1FBQ3hCO0lBQ0o7SUFFQUgsS0FBS0ksUUFBUSxHQUFHO0lBQ2hCLElBQUksT0FBT0osS0FBS04sS0FBSyxDQUFDVyxjQUFjLEtBQUssWUFBWTtRQUNqREwsS0FBS04sS0FBSyxDQUFDVyxjQUFjO0lBQzdCO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRDs7Ozs7Q0FLQyxHQUNELFNBQVNDLE1BQU1DLFdBQVcsRUFBRWIsS0FBSztJQUM3QkosWUFBWWtCLEdBQUcsQ0FBQyxJQUFJLEVBQUU7UUFDbEJEO1FBQ0FiO1FBQ0FlLFlBQVk7UUFDWkMsZUFBZUg7UUFDZkgsVUFBVTtRQUNWTyxTQUFTO1FBQ1RDLGtCQUFrQjtRQUNs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QUFPLElBQ0gzQixLQUFLQyxZQUFZLEtBQUtULGFBQ3RCLE9BQU9RLEtBQUtFLFFBQVEsQ0FBQzBCLFdBQVcsS0FBSyxZQUN2QztnQkFDRTVCLEtBQUtFLFFBQVEsQ0FBQzBCLFdBQVcsQ0FBQ0Y7WUFDOUI7WUFFQSx3REFBd0Q7WUFDeEQsSUFBSXpDLFVBQVV5QyxlQUFlO2dCQUN6QjtZQUNKO1lBRUExQixPQUFPQSxLQUFLRyxJQUFJO1FBQ3BCO1FBQ0FmLG1CQUFtQnNDLGNBQWM7UUFDakN4QyxjQUFjd0MsY0FBYztRQUM1QnZDLGlCQUFpQnVDLGNBQWM7UUFFL0IsT0FBTyxDQUFDQSxhQUFhckUsZ0JBQWdCO0lBQ3pDO0FBQ0o7QUFFQSxtQ0FBbUM7QUFDbkNoRCxPQUFPQyxjQUFjLENBQUN3RyxZQUFZckUsU0FBUyxFQUFFLGVBQWU7SUFDeERqQyxPQUFPc0c7SUFDUG5ELGNBQWM7SUFDZEMsVUFBVTtBQUNkO0FBRUEsZ0VBQWdFO0FBQ2hFLElBQ0ksS0FDeUMsRUFDM0MsRUFFRDtBQUVEckQsNEJBQTRCLEdBQUdrRztBQUMvQmxHLG1CQUFtQixHQUFHdUc7QUFDdEJ2RyxrQkFBZSxHQUFHdUc7QUFFbEJnQixPQUFPdkgsT0FBTyxHQUFHdUc7QUFDakJnQiwwQkFBMEIsR0FBR0EseUJBQXlCLEdBQUdoQjtBQUN6RGdCLG1DQUFtQyxHQUFHckIscUJBQ3RDLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9kaXN0L2V2ZW50LXRhcmdldC1zaGltLmpzP2UyNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAYXV0aG9yIFRvcnUgTmFnYXNoaW1hIDxodHRwczovL2dpdGh1Yi5jb20vbXlzdGljYXRlYT5cbiAqIEBjb3B5cmlnaHQgMjAxNSBUb3J1IE5hZ2FzaGltYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFByaXZhdGVEYXRhXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHt7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50UGhhc2UgVGhlIGN1cnJlbnQgZXZlbnQgcGhhc2UuXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgVGhlIGN1cnJlbnQgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5jZWxlZCBUaGUgZmxhZyB0byBwcmV2ZW50IGRlZmF1bHQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW1tZWRpYXRlU3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgVGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJyZW50IGxpc3RlbmVyIGlzIHBhc3NpdmUuIE90aGVyd2lzZSB0aGlzIGlzIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZVN0YW1wIFRoZSB1bml4IHRpbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhIGZvciBldmVudCB3cmFwcGVycy5cbiAqIEB0eXBlIHtXZWFrTWFwPEV2ZW50LCBQcml2YXRlRGF0YT59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwcml2YXRlRGF0YSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ2FjaGUgZm9yIHdyYXBwZXIgY2xhc3Nlcy5cbiAqIEB0eXBlIHtXZWFrTWFwPE9iamVjdCwgRnVuY3Rpb24+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd3JhcHBlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEdldCBwcml2YXRlIGRhdGEuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcmV0dXJucyB7UHJpdmF0ZURhdGF9IFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGQoZXZlbnQpIHtcbiAgICBjb25zdCByZXR2ID0gcHJpdmF0ZURhdGEuZ2V0KGV2ZW50KTtcbiAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgcmV0diAhPSBudWxsLFxuICAgICAgICBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIixcbiAgICAgICAgZXZlbnRcbiAgICApO1xuICAgIHJldHVybiByZXR2XG59XG5cbi8qKlxuICogaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNzZXQtdGhlLWNhbmNlbGVkLWZsYWdcbiAqIEBwYXJhbSBkYXRhIHtQcml2YXRlRGF0YX0gcHJpdmF0ZSBkYXRhLlxuICovXG5mdW5jdGlvbiBzZXRDYW5jZWxGbGFnKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXNzaXZlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmFibGUgdG8gcHJldmVudERlZmF1bHQgaW5zaWRlIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgaW52b2NhdGlvbi5cIixcbiAgICAgICAgICAgICAgICBkYXRhLnBhc3NpdmVMaXN0ZW5lclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFkYXRhLmV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGF0YS5jYW5jZWxlZCA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIFRoZSBldmVudCB3cmFwcGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50fHt0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICBwcml2YXRlRGF0YS5zZXQodGhpcywge1xuICAgICAgICBldmVudFRhcmdldCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50UGhhc2U6IDIsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxuICAgICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBpbW1lZGlhdGVTdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiBudWxsLFxuICAgICAgICB0aW1lU3RhbXA6IGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpLFxuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jVW5mb3JnZWFibGVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RydXN0ZWRcIiwgeyB2YWx1ZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnQudHlwZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY3VycmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRUYXJnZXRbXX0gVGhlIGNvbXBvc2VkIHBhdGggb2YgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBjb21wb3NlZFBhdGgoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBpZiAoY3VycmVudFRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2N1cnJlbnRUYXJnZXRdXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIE5PTkUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgQ0FQVFVSSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IENBUFRVUklOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgQVRfVEFSR0VULlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEFUX1RBUkdFVCgpIHtcbiAgICAgICAgcmV0dXJuIDJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgQlVCQkxJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQlVCQkxJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAzXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBldmVudFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRQaGFzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGRhdGEuaW1tZWRpYXRlU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYnViYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuYnViYmxlcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY2FuY2VsYWJsZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjb21wb3NlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNvbXBvc2VkKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5peCB0aW1lIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykudGltZVN0YW1wXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgc3JjRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIHN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsQnViYmxlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuc3RvcHBlZFxuICAgIH0sXG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgcmV0dXJuVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAhcGQodGhpcykuY2FuY2VsZWRcbiAgICB9LFxuICAgIHNldCByZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoaXMgZXZlbnQgb2JqZWN0LiBCdXQgZG8gbm90aGluZyB1bmRlciBldmVudCBkaXNwYXRjaGluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSBUaGUgZmxhZyB0byBiZSBwb3NzaWJsZSB0byBidWJibGUgdXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2FuY2VsYWJsZT1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gY2FuY2VsLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgaW5pdEV2ZW50KCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0sXG59O1xuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pO1xuXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50LnByb3RvdHlwZSwgd2luZG93LkV2ZW50LnByb3RvdHlwZSk7XG5cbiAgICAvLyBNYWtlIGFzc29jaWF0aW9uIGZvciB3cmFwcGVycy5cbiAgICB3cmFwcGVycy5zZXQod2luZG93LkV2ZW50LnByb3RvdHlwZSwgRXZlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgdGhlIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFtrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgcGQodGhpcykuZXZlbnRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIGEgZ2l2ZW4gbWV0aG9kIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCB0aGUgbWV0aG9kIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBkKHRoaXMpLmV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50W2tleV0uYXBwbHkoZXZlbnQsIGFyZ3VtZW50cylcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgbmV3IHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBCYXNlRXZlbnQgVGhlIGJhc2Ugd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGRlZmluZWQgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVdyYXBwZXIoQmFzZUV2ZW50LCBwcm90bykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm90byk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCYXNlRXZlbnRcbiAgICB9XG5cbiAgICAvKiogQ3VzdG9tRXZlbnQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgQmFzZUV2ZW50LmNhbGwodGhpcywgZXZlbnRUYXJnZXQsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gQmFzZUV2ZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGlzRnVuY1xuICAgICAgICAgICAgICAgICAgICA/IGRlZmluZUNhbGxEZXNjcmlwdG9yKGtleSlcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFxufVxuXG4vKipcbiAqIEdldCB0aGUgd3JhcHBlciBjbGFzcyBvZiBhIGdpdmVuIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBnZXQgaXRzIHdyYXBwZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcHBlcihwcm90bykge1xuICAgIGlmIChwcm90byA9PSBudWxsIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBFdmVudFxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyID0gd3JhcHBlcnMuZ2V0KHByb3RvKTtcbiAgICBpZiAod3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgIHdyYXBwZXIgPSBkZWZpbmVXcmFwcGVyKGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSksIHByb3RvKTtcbiAgICAgICAgd3JhcHBlcnMuc2V0KHByb3RvLCB3cmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgdG8gbWFuYWdlbWVudCBhIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byB3cmFwLlxuICogQHJldHVybnMge0V2ZW50fSBUaGUgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICBjb25zdCBXcmFwcGVyID0gZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpKTtcbiAgICByZXR1cm4gbmV3IFdyYXBwZXIoZXZlbnRUYXJnZXQsIGV2ZW50KVxufVxuXG4vKipcbiAqIEdldCB0aGUgaW1tZWRpYXRlU3RvcHBlZCBmbGFnIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gZ2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1N0b3BwZWQoZXZlbnQpIHtcbiAgICByZXR1cm4gcGQoZXZlbnQpLmltbWVkaWF0ZVN0b3BwZWRcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2Ugb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZXZlbnRQaGFzZSBOZXcgZXZlbnQgcGhhc2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEV2ZW50UGhhc2UoZXZlbnQsIGV2ZW50UGhhc2UpIHtcbiAgICBwZChldmVudCkuZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2U7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHRhcmdldCBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBOZXcgY3VycmVudCB0YXJnZXQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEN1cnJlbnRUYXJnZXQoZXZlbnQsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICBwZChldmVudCkuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG59XG5cbi8qKlxuICogU2V0IGEgcGFzc2l2ZSBsaXN0ZW5lciBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gcGFzc2l2ZUxpc3RlbmVyIE5ldyBwYXNzaXZlIGxpc3RlbmVyLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRQYXNzaXZlTGlzdGVuZXIoZXZlbnQsIHBhc3NpdmVMaXN0ZW5lcikge1xuICAgIHBkKGV2ZW50KS5wYXNzaXZlTGlzdGVuZXIgPSBwYXNzaXZlTGlzdGVuZXI7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTGlzdGVuZXJOb2RlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogQHByb3BlcnR5IHsxfDJ8M30gbGlzdGVuZXJUeXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhc3NpdmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb25jZVxuICogQHByb3BlcnR5IHtMaXN0ZW5lck5vZGV8bnVsbH0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtXZWFrTWFwPG9iamVjdCwgTWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsaXN0ZW5lcnNNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBMaXN0ZW5lciB0eXBlc1xuY29uc3QgQ0FQVFVSRSA9IDE7XG5jb25zdCBCVUJCTEUgPSAyO1xuY29uc3QgQVRUUklCVVRFID0gMztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIEBwYXJhbSB7YW55fSB4IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxufVxuXG4vKipcbiAqIEdldCBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IHRvIGdldC5cbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+fSBUaGUgbGlzdGVuZXJzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2ZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwLmdldChldmVudFRhcmdldCk7XG4gICAgaWYgKGxpc3RlbmVycyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudFRhcmdldCBvYmplY3QsIGJ1dCBnb3QgYW5vdGhlciB2YWx1ZS5cIlxuICAgICAgICApXG4gICAgfVxuICAgIHJldHVybiBsaXN0ZW5lcnNcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSBldmVudCBhdHRyaWJ1dGUgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZ2V0IHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5saXN0ZW5lclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIHJlbW92aW5nIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBuZXcgdmFsdWUuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJUeXBlOiBBVFRSSUJVVEUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlIChlLmcuIGBldmVudFRhcmdldC5vbmNsaWNrYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRUYXJnZXRQcm90b3R5cGUgVGhlIGV2ZW50IHRhcmdldCBwcm90b3R5cGUgdG8gZGVmaW5lIGFuIGV2ZW50IGF0dHJiaXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBkZWZpbmUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGUoZXZlbnRUYXJnZXRQcm90b3R5cGUsIGV2ZW50TmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgZXZlbnRUYXJnZXRQcm90b3R5cGUsXG4gICAgICAgIGBvbiR7ZXZlbnROYW1lfWAsXG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBjdXN0b20gRXZlbnRUYXJnZXQgd2l0aCBldmVudCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnROYW1lcyBFdmVudCBuYW1lcyBmb3IgZXZlbnQgYXR0cmlidXRlcy5cbiAqIEByZXR1cm5zIHtFdmVudFRhcmdldH0gVGhlIGN1c3RvbSBFdmVudFRhcmdldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGV2ZW50TmFtZXMpIHtcbiAgICAvKiogQ3VzdG9tRXZlbnRUYXJnZXQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudFRhcmdldCgpIHtcbiAgICAgICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGUoQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlLCBldmVudE5hbWVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRUYXJnZXRcbn1cblxuLyoqXG4gKiBFdmVudFRhcmdldC5cbiAqXG4gKiAtIFRoaXMgaXMgY29uc3RydWN0b3IgaWYgbm8gYXJndW1lbnRzLlxuICogLSBUaGlzIGlzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIEN1c3RvbUV2ZW50VGFyZ2V0IGNvbnN0cnVjdG9yIGlmIHRoZXJlIGFyZSBhcmd1bWVudHMuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGNsYXNzIEEgZXh0ZW5kcyBFdmVudFRhcmdldCB7fVxuICogICAgIGNsYXNzIEIgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIikge31cbiAqICAgICBjbGFzcyBDIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIsIFwiZXJyb3JcIikge31cbiAqICAgICBjbGFzcyBEIGV4dGVuZHMgRXZlbnRUYXJnZXQoW1wibWVzc2FnZVwiLCBcImVycm9yXCJdKSB7fVxuICovXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgICBsaXN0ZW5lcnNNYXAuc2V0KHRoaXMsIG5ldyBNYXAoKSk7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGFyZ3VtZW50c1swXSlcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdHlwZXNbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KHR5cGVzKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpXG4gICAgLyplc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIGEgZ2l2ZW4gbGlzdGVuZXIgdG8gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBhZGQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInbGlzdGVuZXInIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdC5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0lzT2JqID0gaXNPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBvcHRpb25zSXNPYmpcbiAgICAgICAgICAgID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpXG4gICAgICAgICAgICA6IEJvb2xlYW4ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFO1xuICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICBsaXN0ZW5lclR5cGUsXG4gICAgICAgICAgICBwYXNzaXZlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLnBhc3NpdmUpLFxuICAgICAgICAgICAgb25jZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IGl0IGFzIHRoZSBmaXJzdCBub2RlIGlmIHRoZSBmaXJzdCBub2RlIGlzIG51bGwuXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIGNoZWNraW5nIGR1cGxpY2F0aW9uLi5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgaWdub3JlIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGl0LlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBnaXZlbiBsaXN0ZW5lciBmcm9tIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gaXNPYmplY3Qob3B0aW9ucylcbiAgICAgICAgICAgID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpXG4gICAgICAgICAgICA6IEJvb2xlYW4ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFO1xuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBnaXZlbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fHt0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGZhbHNlYCBpZiBjYW5jZWxlZC5cbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCA9PSBudWxsIHx8IHR5cGVvZiBldmVudC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV2ZW50LnR5cGVcIiBzaG91bGQgYmUgYSBzdHJpbmcuJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGxpc3RlbmVycyBhcmVuJ3QgcmVnaXN0ZXJlZCwgdGVybWluYXRlLlxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50LnR5cGU7XG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgY2Fubm90IHJld3JpdGUgc2V2ZXJhbCBwcm9wZXJ0aWVzLCBzbyB3cmFwIG9iamVjdC5cbiAgICAgICAgY29uc3Qgd3JhcHBlZEV2ZW50ID0gd3JhcEV2ZW50KHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgcHJvY2VzcyBjYXB0dXJpbmcgcGhhc2UgYW5kIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgICAvLyBUaGlzIGlzbid0IHBhcnRpY2lwYXRpbmcgaW4gYSB0cmVlLlxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGl0J3Mgb25jZVxuICAgICAgICAgICAgaWYgKG5vZGUub25jZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGlzIGxpc3RlbmVyXG4gICAgICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgd3JhcHBlZEV2ZW50LFxuICAgICAgICAgICAgICAgIG5vZGUucGFzc2l2ZSA/IG5vZGUubGlzdGVuZXIgOiBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmNhbGwodGhpcywgd3JhcHBlZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlICE9PSBBVFRSSUJVVEUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50KHdyYXBwZWRFdmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJyZWFrIGlmIGBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25gIHdhcyBjYWxsZWQuXG4gICAgICAgICAgICBpZiAoaXNTdG9wcGVkKHdyYXBwZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcih3cmFwcGVkRXZlbnQsIG51bGwpO1xuICAgICAgICBzZXRFdmVudFBoYXNlKHdyYXBwZWRFdmVudCwgMCk7XG4gICAgICAgIHNldEN1cnJlbnRUYXJnZXQod3JhcHBlZEV2ZW50LCBudWxsKTtcblxuICAgICAgICByZXR1cm4gIXdyYXBwZWRFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogRXZlbnRUYXJnZXQsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbi8vIEVuc3VyZSBgZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRUYXJnZXRgIGlzIGB0cnVlYC5cbmlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIlxuKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7XG59XG5cbmV4cG9ydHMuZGVmaW5lRXZlbnRBdHRyaWJ1dGUgPSBkZWZpbmVFdmVudEF0dHJpYnV0ZTtcbmV4cG9ydHMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50VGFyZ2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0XG5tb2R1bGUuZXhwb3J0cy5FdmVudFRhcmdldCA9IG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEV2ZW50VGFyZ2V0XG5tb2R1bGUuZXhwb3J0cy5kZWZpbmVFdmVudEF0dHJpYnV0ZSA9IGRlZmluZUV2ZW50QXR0cmlidXRlXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC10YXJnZXQtc2hpbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInByaXZhdGVEYXRhIiwiV2Vha01hcCIsIndyYXBwZXJzIiwicGQiLCJldmVudCIsInJldHYiLCJnZXQiLCJjb25zb2xlIiwiYXNzZXJ0Iiwic2V0Q2FuY2VsRmxhZyIsImRhdGEiLCJwYXNzaXZlTGlzdGVuZXIiLCJlcnJvciIsImNhbmNlbGFibGUiLCJjYW5jZWxlZCIsInByZXZlbnREZWZhdWx0IiwiRXZlbnQiLCJldmVudFRhcmdldCIsInNldCIsImV2ZW50UGhhc2UiLCJjdXJyZW50VGFyZ2V0Iiwic3RvcHBlZCIsImltbWVkaWF0ZVN0b3BwZWQiLCJ0aW1lU3RhbXAiLCJEYXRlIiwibm93IiwiZW51bWVyYWJsZSIsImtleXMiLCJpIiwibGVuZ3RoIiwia2V5IiwiZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yIiwicHJvdG90eXBlIiwidHlwZSIsInRhcmdldCIsImNvbXBvc2VkUGF0aCIsIk5PTkUiLCJDQVBUVVJJTkdfUEhBU0UiLCJBVF9UQVJHRVQiLCJCVUJCTElOR19QSEFTRSIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImJ1YmJsZXMiLCJCb29sZWFuIiwiZGVmYXVsdFByZXZlbnRlZCIsImNvbXBvc2VkIiwic3JjRWxlbWVudCIsImNhbmNlbEJ1YmJsZSIsInJldHVyblZhbHVlIiwiaW5pdEV2ZW50IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ3aW5kb3ciLCJzZXRQcm90b3R5cGVPZiIsImRlZmluZUNhbGxEZXNjcmlwdG9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJkZWZpbmVXcmFwcGVyIiwiQmFzZUV2ZW50IiwicHJvdG8iLCJDdXN0b21FdmVudCIsImNhbGwiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImRlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc0Z1bmMiLCJnZXRXcmFwcGVyIiwid3JhcHBlciIsImdldFByb3RvdHlwZU9mIiwid3JhcEV2ZW50IiwiV3JhcHBlciIsImlzU3RvcHBlZCIsInNldEV2ZW50UGhhc2UiLCJzZXRDdXJyZW50VGFyZ2V0Iiwic2V0UGFzc2l2ZUxpc3RlbmVyIiwibGlzdGVuZXJzTWFwIiwiQ0FQVFVSRSIsIkJVQkJMRSIsIkFUVFJJQlVURSIsImlzT2JqZWN0IiwieCIsImdldExpc3RlbmVycyIsImxpc3RlbmVycyIsIlR5cGVFcnJvciIsImRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvciIsImV2ZW50TmFtZSIsIm5vZGUiLCJsaXN0ZW5lclR5cGUiLCJsaXN0ZW5lciIsIm5leHQiLCJwcmV2IiwiZGVsZXRlIiwibmV3Tm9kZSIsInBhc3NpdmUiLCJvbmNlIiwiZGVmaW5lRXZlbnRBdHRyaWJ1dGUiLCJldmVudFRhcmdldFByb3RvdHlwZSIsImRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0IiwiZXZlbnROYW1lcyIsIkN1c3RvbUV2ZW50VGFyZ2V0IiwiRXZlbnRUYXJnZXQiLCJNYXAiLCJBcnJheSIsImlzQXJyYXkiLCJ0eXBlcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvcHRpb25zIiwib3B0aW9uc0lzT2JqIiwiY2FwdHVyZSIsInVuZGVmaW5lZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50Iiwid3JhcHBlZEV2ZW50IiwiZXJyIiwiaGFuZGxlRXZlbnQiLCJkZWZhdWx0IiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/event-target-shim/dist/event-target-shim.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/event-target-shim/dist/event-target-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/event-target-shim/dist/event-target-shim.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

eval("/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */ /**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */ const privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */ const wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */ function pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */ function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n        }\n        return;\n    }\n    if (!data.event.cancelable) {\n        return;\n    }\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */ /**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */ function Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now()\n    });\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", {\n        value: false,\n        enumerable: true\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */ get type () {\n        return pd(this).event.type;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get target () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */ composedPath () {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return [];\n        }\n        return [\n            currentTarget\n        ];\n    },\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */ get NONE () {\n        return 0;\n    },\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */ get CAPTURING_PHASE () {\n        return 1;\n    },\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */ get AT_TARGET () {\n        return 2;\n    },\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */ get BUBBLING_PHASE () {\n        return 3;\n    },\n    /**\n     * The target of this event.\n     * @type {number}\n     */ get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopPropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopImmediatePropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */ get bubbles () {\n        return Boolean(pd(this).event.bubbles);\n    },\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */ get cancelable () {\n        return Boolean(pd(this).event.cancelable);\n    },\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */ preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */ get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */ get composed () {\n        return Boolean(pd(this).event.composed);\n    },\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */ get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */ get srcElement () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */ get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (value){\n        if (!value) {\n            return;\n        }\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */ get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (value){\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */ initEvent () {\n    // Do nothing.\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n});\n// Ensure `event instanceof window.Event` is `true`.\nif (false) {}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */ function defineRedirectDescriptor(key) {\n    return {\n        get () {\n            return pd(this).event[key];\n        },\n        set (value1) {\n            pd(this).event[key] = value1;\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */ function defineCallDescriptor(key) {\n    return {\n        value () {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments);\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */ function defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent;\n    }\n    /** CustomEvent */ function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: {\n            value: CustomEvent,\n            configurable: true,\n            writable: true\n        }\n    });\n    // Define accessors.\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n        }\n    }\n    return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */ function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event;\n    }\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */ function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */ function isStopped(event) {\n    return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */ function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */ function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */ function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */ /**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */ const listenersMap = new WeakMap();\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */ function isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n    ;\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */ function getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n    return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */ function defineEventAttributeDescriptor(eventName) {\n    return {\n        get () {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener;\n                }\n                node = node.next;\n            }\n            return null;\n        },\n        set (listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n                node = node.next;\n            }\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */ function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */ function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */ function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true\n        }\n    });\n    for(let i = 0; i < eventNames.length; ++i){\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */ function EventTarget() {\n    /*eslint-disable consistent-return */ if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0]);\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; ++i){\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n/*eslint-enable consistent-return */ }\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ addEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\");\n        }\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null\n        };\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return;\n        }\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n        // Add it.\n        prev.next = newNode;\n    },\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ removeEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        let prev = null;\n        let node = listeners.get(eventName);\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n    },\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */ dispatchEvent (event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.');\n        }\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true;\n        }\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while(node != null){\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n            // Call this listener\n            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err);\n                    }\n                }\n            } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break;\n            }\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n        return !wrappedEvent.defaultPrevented;\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n});\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (false) {}\nexports.defineEventAttribute = defineEventAttribute;\nexports.EventTarget = EventTarget;\nexports[\"default\"] = EventTarget;\nmodule.exports = EventTarget;\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget;\nmodule.exports.defineEventAttribute = defineEventAttribute //# sourceMappingURL=event-target-shim.js.map\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vZGlzdC9ldmVudC10YXJnZXQtc2hpbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBQ0Q7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0Q7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7Ozs7Q0FJQyxHQUNELE1BQU1DLGNBQWMsSUFBSUM7QUFFeEI7Ozs7Q0FJQyxHQUNELE1BQU1DLFdBQVcsSUFBSUQ7QUFFckI7Ozs7O0NBS0MsR0FDRCxTQUFTRSxHQUFHQyxLQUFLO0lBQ2IsTUFBTUMsT0FBT0wsWUFBWU0sR0FBRyxDQUFDRjtJQUM3QkcsUUFBUUMsTUFBTSxDQUNWSCxRQUFRLE1BQ1IsK0NBQ0FEO0lBRUosT0FBT0M7QUFDWDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNJLGNBQWNDLElBQUk7SUFDdkIsSUFBSUEsS0FBS0MsZUFBZSxJQUFJLE1BQU07UUFDOUIsSUFDSSxPQUFPSixZQUFZLGVBQ25CLE9BQU9BLFFBQVFLLEtBQUssS0FBSyxZQUMzQjtZQUNFTCxRQUFRSyxLQUFLLENBQ1Qsc0VBQ0FGLEtBQUtDLGVBQWU7UUFFNUI7UUFDQTtJQUNKO0lBQ0EsSUFBSSxDQUFDRCxLQUFLTixLQUFLLENBQUNTLFVBQVUsRUFBRTtRQUN4QjtJQUNKO0lBRUFILEtBQUtJLFFBQVEsR0FBRztJQUNoQixJQUFJLE9BQU9KLEtBQUtOLEtBQUssQ0FBQ1csY0FBYyxLQUFLLFlBQVk7UUFDakRMLEtBQUtOLEtBQUssQ0FBQ1csY0FBYztJQUM3QjtBQUNKO0FBRUE7OztDQUdDLEdBQ0Q7Ozs7O0NBS0MsR0FDRCxTQUFTQyxNQUFNQyxXQUFXLEVBQUViLEtBQUs7SUFDN0JKLFlBQVlrQixHQUFHLENBQUMsSUFBSSxFQUFFO1FBQ2xCRDtRQUNBYjtRQUNBZSxZQUFZO1FBQ1pDLGVBQWVIO1FBQ2ZILFVBQVU7UUFDVk8sU0FBUztRQUNUQyxrQkFBa0I7UUFDbEJYLGlCQUFpQjtR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S0FBS0MsWUFBWSxLQUFLVCxhQUN0QixPQUFPUSxLQUFLRSxRQUFRLENBQUMwQixXQUFXLEtBQUssWUFDdkM7Z0JBQ0U1QixLQUFLRSxRQUFRLENBQUMwQixXQUFXLENBQUNGO1lBQzlCO1lBRUEsd0RBQXdEO1lBQ3hELElBQUl6QyxVQUFVeUMsZUFBZTtnQkFDekI7WUFDSjtZQUVBMUIsT0FBT0EsS0FBS0csSUFBSTtRQUNwQjtRQUNBZixtQkFBbUJzQyxjQUFjO1FBQ2pDeEMsY0FBY3dDLGNBQWM7UUFDNUJ2QyxpQkFBaUJ1QyxjQUFjO1FBRS9CLE9BQU8sQ0FBQ0EsYUFBYXJFLGdCQUFnQjtJQUN6QztBQUNKO0FBRUEsbUNBQW1DO0FBQ25DaEQsT0FBT0MsY0FBYyxDQUFDd0csWUFBWXJFLFNBQVMsRUFBRSxlQUFlO0lBQ3hEakMsT0FBT3NHO0lBQ1BuRCxjQUFjO0lBQ2RDLFVBQVU7QUFDZDtBQUVBLGdFQUFnRTtBQUNoRSxJQUNJLEtBQ3lDLEVBQzNDLEVBRUQ7QUFFRHJELDRCQUE0QixHQUFHa0c7QUFDL0JsRyxtQkFBbUIsR0FBR3VHO0FBQ3RCdkcsa0JBQWUsR0FBR3VHO0FBRWxCZ0IsT0FBT3ZILE9BQU8sR0FBR3VHO0FBQ2pCZ0IsMEJBQTBCLEdBQUdBLHlCQUF5QixHQUFHaEI7QUFDekRnQixtQ0FBbUMsR0FBR3JCLHFCQUN0Qyw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vZGlzdC9ldmVudC10YXJnZXQtc2hpbS5qcz9lMjUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYSA8aHR0cHM6Ly9naXRodWIuY29tL215c3RpY2F0ZWE+XG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTZWUgTElDRU5TRSBmaWxlIGluIHJvb3QgZGlyZWN0b3J5IGZvciBmdWxsIGxpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcml2YXRlRGF0YVxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudFBoYXNlIFRoZSBjdXJyZW50IGV2ZW50IHBoYXNlLlxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IFRoZSBjdXJyZW50IGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FuY2VsZWQgVGhlIGZsYWcgdG8gcHJldmVudCBkZWZhdWx0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBzdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGltbWVkaWF0ZVN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258bnVsbH0gcGFzc2l2ZUxpc3RlbmVyIFRoZSBsaXN0ZW5lciBpZiB0aGUgY3VycmVudCBsaXN0ZW5lciBpcyBwYXNzaXZlLiBPdGhlcndpc2UgdGhpcyBpcyBudWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVTdGFtcCBUaGUgdW5peCB0aW1lLlxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKiBAdHlwZSB7V2Vha01hcDxFdmVudCwgUHJpdmF0ZURhdGE+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENhY2hlIGZvciB3cmFwcGVyIGNsYXNzZXMuXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdyYXBwZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHJldHVybnMge1ByaXZhdGVEYXRhfSBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBkKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0diA9IHByaXZhdGVEYXRhLmdldChldmVudCk7XG4gICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgIHJldHYgIT0gbnVsbCxcbiAgICAgICAgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnQgb2JqZWN0LCBidXQgZ290XCIsXG4gICAgICAgIGV2ZW50XG4gICAgKTtcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jc2V0LXRoZS1jYW5jZWxlZC1mbGFnXG4gKiBAcGFyYW0gZGF0YSB7UHJpdmF0ZURhdGF9IHByaXZhdGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FuY2VsRmxhZyhkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFzc2l2ZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IGluc2lkZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGludm9jYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgZGF0YS5wYXNzaXZlTGlzdGVuZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghZGF0YS5ldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRhdGEuY2FuY2VsZWQgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBUaGUgZXZlbnQgd3JhcHBlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgcHJpdmF0ZURhdGEuc2V0KHRoaXMsIHtcbiAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudFBoYXNlOiAyLFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlU3RvcHBlZDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI1VuZm9yZ2VhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29yc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50LnR5cGVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0V2ZW50VGFyZ2V0W119IFRoZSBjb21wb3NlZCBwYXRoIG9mIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgY29tcG9zZWRQYXRoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gcGQodGhpcykuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJyZW50VGFyZ2V0XVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBOT05FLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIENBUFRVUklOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBBVF9UQVJHRVQoKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEJVQkJMSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gM1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50UGhhc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcFByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhLmltbWVkaWF0ZVN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmJ1YmJsZXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNhbmNlbGFibGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNhbmNlbGFibGUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGlzIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gaW5kaWNhdGUgY2FuY2VsbGF0aW9uIHN0YXRlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY2FuY2VsZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY29tcG9zZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNvbXBvc2VkKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jb21wb3NlZClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXggdGltZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLnRpbWVTdGFtcFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IHNyY0VsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBzdG9wIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IGNhbmNlbEJ1YmJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLnN0b3BwZWRcbiAgICB9LFxuICAgIHNldCBjYW5jZWxCdWJibGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gaW5kaWNhdGUgY2FuY2VsbGF0aW9uIHN0YXRlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0IHJldHVyblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gIXBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcbiAgICBzZXQgcmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgc2V0Q2FuY2VsRmxhZyhwZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGV2ZW50IG9iamVjdC4gQnV0IGRvIG5vdGhpbmcgdW5kZXIgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYnViYmxlcz1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gYnViYmxlIHVwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbGFibGU9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGNhbmNlbC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGluaXRFdmVudCgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KTtcblxuLy8gRW5zdXJlIGBldmVudCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudGAgaXMgYHRydWVgLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5FdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudC5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWFrZSBhc3NvY2lhdGlvbiBmb3Igd3JhcHBlcnMuXG4gICAgd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIEV2ZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IHRoZSBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRba2V5XVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHBkKHRoaXMpLmV2ZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCBhIGdpdmVuIG1ldGhvZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgdGhlIG1ldGhvZCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNhbGxEZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwZCh0aGlzKS5ldmVudDtcbiAgICAgICAgICAgIHJldHVybiBldmVudFtrZXldLmFwcGx5KGV2ZW50LCBhcmd1bWVudHMpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIG5ldyB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQmFzZUV2ZW50IFRoZSBiYXNlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBkZWZpbmVkIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVXcmFwcGVyKEJhc2VFdmVudCwgcHJvdG8pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQmFzZUV2ZW50XG4gICAgfVxuXG4gICAgLyoqIEN1c3RvbUV2ZW50ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIEJhc2VFdmVudC5jYWxsKHRoaXMsIGV2ZW50VGFyZ2V0LCBldmVudCk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDdXN0b21FdmVudCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCEoa2V5IGluIEJhc2VFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzRnVuYyA9IHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBpc0Z1bmNcbiAgICAgICAgICAgICAgICAgICAgPyBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICAgICAgICAgIDogZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdyYXBwZXIgY2xhc3Mgb2YgYSBnaXZlbiBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZ2V0IGl0cyB3cmFwcGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBwZXIocHJvdG8pIHtcbiAgICBpZiAocHJvdG8gPT0gbnVsbCB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRcbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlciA9IHdyYXBwZXJzLmdldChwcm90byk7XG4gICAgaWYgKHdyYXBwZXIgPT0gbnVsbCkge1xuICAgICAgICB3cmFwcGVyID0gZGVmaW5lV3JhcHBlcihnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpLCBwcm90byk7XG4gICAgICAgIHdyYXBwZXJzLnNldChwcm90bywgd3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbi8qKlxuICogV3JhcCBhIGdpdmVuIGV2ZW50IHRvIG1hbmFnZW1lbnQgYSBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIHdyYXBwZXIgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgY29uc3QgV3JhcHBlciA9IGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSk7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVyKGV2ZW50VGFyZ2V0LCBldmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZVN0b3BwZWQgZmxhZyBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGdldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIHBkKGV2ZW50KS5pbW1lZGlhdGVTdG9wcGVkXG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50UGhhc2UgTmV3IGV2ZW50IHBoYXNlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRFdmVudFBoYXNlKGV2ZW50LCBldmVudFBoYXNlKSB7XG4gICAgcGQoZXZlbnQpLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB0YXJnZXQgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgTmV3IGN1cnJlbnQgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50VGFyZ2V0KGV2ZW50LCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgcGQoZXZlbnQpLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xufVxuXG4vKipcbiAqIFNldCBhIHBhc3NpdmUgbGlzdGVuZXIgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBOZXcgcGFzc2l2ZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0UGFzc2l2ZUxpc3RlbmVyKGV2ZW50LCBwYXNzaXZlTGlzdGVuZXIpIHtcbiAgICBwZChldmVudCkucGFzc2l2ZUxpc3RlbmVyID0gcGFzc2l2ZUxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExpc3RlbmVyTm9kZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7MXwyfDN9IGxpc3RlbmVyVHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzaXZlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJOb2RlfG51bGx9IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbGlzdGVuZXJzTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gTGlzdGVuZXIgdHlwZXNcbmNvbnN0IENBUFRVUkUgPSAxO1xuY29uc3QgQlVCQkxFID0gMjtcbmNvbnN0IEFUVFJJQlVURSA9IDM7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCBvciBub3QuXG4gKiBAcGFyYW0ge2FueX0geCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbn1cblxuLyoqXG4gKiBHZXQgbGlzdGVuZXJzLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCB0byBnZXQuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPn0gVGhlIGxpc3RlbmVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVycyhldmVudFRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcC5nZXQoZXZlbnRUYXJnZXQpO1xuICAgIGlmIChsaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnRUYXJnZXQgb2JqZWN0LCBidXQgZ290IGFub3RoZXIgdmFsdWUuXCJcbiAgICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzXG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgZXZlbnQgYXR0cmlidXRlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGdldCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGlzdGVuZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSByZW1vdmluZyBvbGQgdmFsdWUuXG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyVHlwZTogQVRUUklCVVRFLFxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGV2ZW50IGF0dHJpYnV0ZSAoZS5nLiBgZXZlbnRUYXJnZXQub25jbGlja2ApLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50VGFyZ2V0UHJvdG90eXBlIFRoZSBldmVudCB0YXJnZXQgcHJvdG90eXBlIHRvIGRlZmluZSBhbiBldmVudCBhdHRyYml0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZGVmaW5lLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlKGV2ZW50VGFyZ2V0UHJvdG90eXBlLCBldmVudE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIGV2ZW50VGFyZ2V0UHJvdG90eXBlLFxuICAgICAgICBgb24ke2V2ZW50TmFtZX1gLFxuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKVxuICAgICk7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgY3VzdG9tIEV2ZW50VGFyZ2V0IHdpdGggZXZlbnQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50TmFtZXMgRXZlbnQgbmFtZXMgZm9yIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJucyB7RXZlbnRUYXJnZXR9IFRoZSBjdXN0b20gRXZlbnRUYXJnZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChldmVudE5hbWVzKSB7XG4gICAgLyoqIEN1c3RvbUV2ZW50VGFyZ2V0ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBDdXN0b21FdmVudFRhcmdldCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgZXZlbnROYW1lc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0XG59XG5cbi8qKlxuICogRXZlbnRUYXJnZXQuXG4gKlxuICogLSBUaGlzIGlzIGNvbnN0cnVjdG9yIGlmIG5vIGFyZ3VtZW50cy5cbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBjbGFzcyBBIGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAqICAgICBjbGFzcyBCIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIpIHt9XG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XG4gKiAgICAgY2xhc3MgRCBleHRlbmRzIEV2ZW50VGFyZ2V0KFtcIm1lc3NhZ2VcIiwgXCJlcnJvclwiXSkge31cbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChhcmd1bWVudHNbMF0pXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCh0eXBlcylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2xpc3RlbmVyJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNJc09iaiA9IGlzT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gb3B0aW9uc0lzT2JqXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRTtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgbGlzdGVuZXJUeXBlLFxuICAgICAgICAgICAgcGFzc2l2ZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgICAgIG9uY2U6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMub25jZSksXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBpdCBhcyB0aGUgZmlyc3Qgbm9kZSBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBudWxsLlxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSBjaGVja2luZyBkdXBsaWNhdGlvbi4uXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGlnbm9yZSBkdXBsaWNhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBpdC5cbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZ2l2ZW4gbGlzdGVuZXIgZnJvbSB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGlzT2JqZWN0KG9wdGlvbnMpXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRTtcblxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuY2VsZWQuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT0gbnVsbCB8fCB0eXBlb2YgZXZlbnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJldmVudC50eXBlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsaXN0ZW5lcnMgYXJlbid0IHJlZ2lzdGVyZWQsIHRlcm1pbmF0ZS5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudC50eXBlO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbm5vdCByZXdyaXRlIHNldmVyYWwgcHJvcGVydGllcywgc28gd3JhcCBvYmplY3QuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IHdyYXBFdmVudCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHByb2Nlc3MgY2FwdHVyaW5nIHBoYXNlIGFuZCBidWJibGluZyBwaGFzZS5cbiAgICAgICAgLy8gVGhpcyBpc24ndCBwYXJ0aWNpcGF0aW5nIGluIGEgdHJlZS5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBsaXN0ZW5lciBpZiBpdCdzIG9uY2VcbiAgICAgICAgICAgIGlmIChub2RlLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKFxuICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudCxcbiAgICAgICAgICAgICAgICBub2RlLnBhc3NpdmUgPyBub2RlLmxpc3RlbmVyIDogbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5saXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5jYWxsKHRoaXMsIHdyYXBwZWRFdmVudCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSAhPT0gQVRUUklCVVRFICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgaWYgKGlzU3RvcHBlZCh3cmFwcGVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIod3JhcHBlZEV2ZW50LCBudWxsKTtcbiAgICAgICAgc2V0RXZlbnRQaGFzZSh3cmFwcGVkRXZlbnQsIDApO1xuICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KHdyYXBwZWRFdmVudCwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuICF3cmFwcGVkRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgIH0sXG59O1xuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50VGFyZ2V0LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pO1xuXG4vLyBFbnN1cmUgYGV2ZW50VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0YCBpcyBgdHJ1ZWAuXG5pZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiB3aW5kb3cuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCJcbikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUpO1xufVxuXG5leHBvcnRzLmRlZmluZUV2ZW50QXR0cmlidXRlID0gZGVmaW5lRXZlbnRBdHRyaWJ1dGU7XG5leHBvcnRzLkV2ZW50VGFyZ2V0ID0gRXZlbnRUYXJnZXQ7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFRhcmdldDtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldFxubW9kdWxlLmV4cG9ydHMuRXZlbnRUYXJnZXQgPSBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFdmVudFRhcmdldFxubW9kdWxlLmV4cG9ydHMuZGVmaW5lRXZlbnRBdHRyaWJ1dGUgPSBkZWZpbmVFdmVudEF0dHJpYnV0ZVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQtdGFyZ2V0LXNoaW0uanMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwcml2YXRlRGF0YSIsIldlYWtNYXAiLCJ3cmFwcGVycyIsInBkIiwiZXZlbnQiLCJyZXR2IiwiZ2V0IiwiY29uc29sZSIsImFzc2VydCIsInNldENhbmNlbEZsYWciLCJkYXRhIiwicGFzc2l2ZUxpc3RlbmVyIiwiZXJyb3IiLCJjYW5jZWxhYmxlIiwiY2FuY2VsZWQiLCJwcmV2ZW50RGVmYXVsdCIsIkV2ZW50IiwiZXZlbnRUYXJnZXQiLCJzZXQiLCJldmVudFBoYXNlIiwiY3VycmVudFRhcmdldCIsInN0b3BwZWQiLCJpbW1lZGlhdGVTdG9wcGVkIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImVudW1lcmFibGUiLCJrZXlzIiwiaSIsImxlbmd0aCIsImtleSIsImRlZmluZVJlZGlyZWN0RGVzY3JpcHRvciIsInByb3RvdHlwZSIsInR5cGUiLCJ0YXJnZXQiLCJjb21wb3NlZFBhdGgiLCJOT05FIiwiQ0FQVFVSSU5HX1BIQVNFIiwiQVRfVEFSR0VUIiwiQlVCQkxJTkdfUEhBU0UiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJidWJibGVzIiwiQm9vbGVhbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb21wb3NlZCIsInNyY0VsZW1lbnQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImluaXRFdmVudCIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwid2luZG93Iiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVDYWxsRGVzY3JpcHRvciIsImFwcGx5IiwiYXJndW1lbnRzIiwiZGVmaW5lV3JhcHBlciIsIkJhc2VFdmVudCIsInByb3RvIiwiQ3VzdG9tRXZlbnQiLCJjYWxsIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNGdW5jIiwiZ2V0V3JhcHBlciIsIndyYXBwZXIiLCJnZXRQcm90b3R5cGVPZiIsIndyYXBFdmVudCIsIldyYXBwZXIiLCJpc1N0b3BwZWQiLCJzZXRFdmVudFBoYXNlIiwic2V0Q3VycmVudFRhcmdldCIsInNldFBhc3NpdmVMaXN0ZW5lciIsImxpc3RlbmVyc01hcCIsIkNBUFRVUkUiLCJCVUJCTEUiLCJBVFRSSUJVVEUiLCJpc09iamVjdCIsIngiLCJnZXRMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJUeXBlRXJyb3IiLCJkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IiLCJldmVudE5hbWUiLCJub2RlIiwibGlzdGVuZXJUeXBlIiwibGlzdGVuZXIiLCJuZXh0IiwicHJldiIsImRlbGV0ZSIsIm5ld05vZGUiLCJwYXNzaXZlIiwib25jZSIsImRlZmluZUV2ZW50QXR0cmlidXRlIiwiZXZlbnRUYXJnZXRQcm90b3R5cGUiLCJkZWZpbmVDdXN0b21FdmVudFRhcmdldCIsImV2ZW50TmFtZXMiLCJDdXN0b21FdmVudFRhcmdldCIsIkV2ZW50VGFyZ2V0IiwiTWFwIiwiQXJyYXkiLCJpc0FycmF5IiwidHlwZXMiLCJhZGRFdmVudExpc3RlbmVyIiwib3B0aW9ucyIsIm9wdGlvbnNJc09iaiIsImNhcHR1cmUiLCJ1bmRlZmluZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIndyYXBwZWRFdmVudCIsImVyciIsImhhbmRsZUV2ZW50IiwiZGVmYXVsdCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/event-target-shim/dist/event-target-shim.js\n");

/***/ })

};
;